\documentclass{article}
\title{Funktionale Programmierung Mitschrieb}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\fancyhf{}
\fancyhead[C]{Torsten Grust - Functional Programming}
\usepackage{fontspec}
\setmonofont{Andale Mono}
\usepackage[english]{babel}
\author{Finn Ickler}
\usepackage{mdframed}
\usepackage{epigraph}
\usepackage{minted}
\renewcommand{\listingscaption}{Code example}
\newcommand{\Haskell}[1]{\mintinline{Haskell}{#1}}
\setcounter{secnumdepth}{-1}
\begin{document}
\maketitle
\epigraph{\glqq Avoid success at all cost \grqq}{Simon Peyton Jones}
\tableofcontents
\listoflistings
\section{Vorlesung 1}
\begin{listing}
\caption{Hello World}
\begin{minted}{haskell}
-- Hello World Haskell
main :: IO ()
main = putStrLn "Chewie, we're home"
\end{minted}
\end{listing}
\subsection{Functional Programming (FP)}
A programming language is a medium for expressive ideas (not to get a computer to perform operations ). Thus programs must be written for people to read, and only incidentally for machines.
\subsection{Computational Model in FP : \emph{Reduction}}
Replace expressions by their value.\\
IN FP, expressions are formed by applying functions to values.
\begin{enumerate}
\item Function as in maths: $x = y \rightarrow f(x) = f(y)$
\item Functions are values like numbers or text
\end{enumerate}
\begin{tabular}{l|c|c}
&FP&Imperative\\
construction & function application and composition & statement sequencing\\
execution & reduction (expression evaluation) & state changes\\
semantics & $\lambda$-calculus&denotational
\end{tabular}\bigskip\\
$ n \in \mathbb{N}, n \geq 2$ is a prime number $\Leftrightarrow$ the set of non-trivial factors of n is empty.\\
$n$ is prime $\Leftrightarrow \{ m \mid m \in m \in \{2,\ldots,n-1\}, n mod m = 0 \} = \{\}$\\
\begin{listing}[h!]
\begin{minted}{c}
int IsPrime(int n)
{
    int m;
    int found_factor;
    found_factor
    for (m = 2; m <= n -1; m++)
    {
        if (n % m == 0)
        {
            found_factor = 1 ;
            break;
        }
    }
    return !found_factor;
}
\end{minted}
\caption{isPrime in C}
\end{listing}
\begin{listing}[h!]
\begin{minted}{Haskell}
isPrime :: Integer -> Bool
isPrime n = factors n == []
  where 
    factors :: Integer -> [Integer]
    factors n = [ m  | m <- [2..n-1], mod n m == 0]

main :: IO ()
main = do
  let n = 42
  print (isPrime n)
\end{minted}
\caption{isPrime in Haskell}
\end{listing}
\newpage
\usemintedstyle[Haskell]{bw}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\begin{listing}[h!]
\begin{minted}[bgcolor=bg]{Haskell}
let xs = [ x+1 | x <- [0..9] ]
:sprint xs = _
length xs
:sprint xs = [_,_,_,_,_,_,_,_,_]
\end{minted}
\caption{Lazy Evaluation in der ghci REPL}
\end{listing}
\usemintedstyle[Haskell]{default}
\subsection{Haskell Ramp Up}
Read $\equiv$ as ''denotes the same value as''\\
Apply f to value e:\quad f \textvisiblespace e \\(juxtaposition, ''apply'', binary operator \textvisiblespace, Haskell speak: infixL 10 \textvisiblespace)
= \textvisiblespace has max precedence (10): f $e_1$ +$e_2 \equiv $(f $e_1$) + $e_2$
\textvisiblespace associates to the left g \textvisiblespace f \textvisiblespace e $\equiv$ (g f) e
Function composition:
\begin{enumerate}[-]
\item g (f e)
\item Operator ''.'' (''after'') : (g.f) e (. = $\circ$) = g(f (e))
\item Alternative ''apply'' operator \$ (lowest precedence, associates to the right), infix 0\$): f\$$e_1$+ $e_2$ = f ($e_1 + e_2$)
\end{enumerate}
\section{Vorlesung 2}
\begin{listing}
\caption{Verschiedene Schreibweise einer Applikation}
\begin{minted}[bgcolor=bg]{Haskell}
cos 2 * pi
cos (2 * pi)
cos $ 2 * pi
isLetter (head (reverse ("It's a " ++ "Trap")))
(isLetter . head . reverse ) ("It's a" ++ "Trap")
isLetter $ head $ reverse $ "It's a" ++ "Trap"
\end{minted}
\end{listing}
\noindent Prefix application of binary infix operator $\oplus$
\begin{minted}[escapeinside=||]{Haskell}
(|$\oplus) e_1 e_2 \equiv e_1 \oplus e_2$|
|$(\&\&)$| True False |$\equiv$| False
\end{minted}
Infix application of binary function f:
\begin{minted}[escapeinside=||]{Haskell}
|$e_1$| `f` |$e_2$| |$\equiv$| f |$e_1 e_2$|
x `elem` xs |$\equiv$| x |$\in$| xs
\end{minted}
User defined operators with characters : \mintinline{Haskell}|!#%&*+/<=>?@\^|~|
\begin{listing}
\caption{Eigener $\approx$ Opperator}
\begin{minted}{Haskell}
epsilon :: Double
epsilon = 0.00001
(~=~) :: Double -> Double -> Bool
x ~=~ y = abs (x - y) < epsilon
infix 4 ~=~ 
\end{minted}
\end{listing}
\subsection{Values and Types}
Read \mintinline{Haskell}|::| as ''has type''\\
Any Haskell value e has a type t (\mintinline{Haskell}{e::t}) that is determined at compile time.\\
The \mintinline{Haskell}|::| type assignment is either given explicitly or inferred by the computer
\subsection{Types}
\begin{tabular}{lll}
Type&Description&Value\\
\hline
Int & fixed precision integers ($-2^{63}\ldots2^{63}-1$)&\Haskell{0,1,42}\\
Integer & arbitrary Precision integers & \Haskell{0,10^100}\\
Float,Double & Single/Double precision floating points & \Haskell{0.1,1e03}\\
Char & Unicode Character&\mintinline[escapeinside=||]{Haskell}{'x','\t', '△', '\8710'}\\
Bool & Booleans & \mintinline[escapeinside=||]{Haskell}{True, False}\\
() & Unit (single-value type) & \mintinline[escapeinside=||]{Haskell}{()}
\end{tabular}
\begin{minted}[bgcolor =bg]{Haskell}
2
it :: Integer
42 :: Int 
it :: Int
'a' 
it :: Char
True 
it :: Bool
10^100 
it :: Integer
10^100 :: Double 
it :: Double
\end{minted}
\subsection{Type Constructors}
\begin{itemize}
\item Build new types from existing Types
\item Let a,b denote arbitrary Types (type variables)
\end{itemize}
\begin{tabular}{lp{6cm}l}
Type Constructor& Description & Values\\
\hline
(a,b)&pairs of values of types a and b& \Haskell{(1,True) :: (Int, Bool)}\\
($\text{a}_1,\text{a}_2,\ldots,\text{a}_n$)& n-Types& \Haskell{2,False :: (Int, Bool)}\\
\lbrack a\rbrack &list of values of type a & \Haskell{[] :: [a]}\\
\Haskell{Maybe} a & optional value of type a & \Haskell{Just 42 Maybe Integer}\\
& & \Haskell{Nothing :: Maybe a}\\
\Haskell{Either} a b & Choice between values of Type a and b& \Haskell{Left 'x' :: Either Char b}\\
& & \Haskell{Right pi :: Either a Double}\\
\Haskell{IO} a & I/O action that returns a value of type a (can habe side effects ) & \Haskell{print 42 :: IO} ()\\
& & \Haskell{getChar :: IO Char}\\
a \Haskell{->} b & function from type a to b & \Haskell{isLetter :: Char -> Bool}
\end{tabular}
\begin{minted}[bgcolor=bg]{Haskell}
(1, '1', 1.0)
it :: (Integer, Char, Double)
[1, '1', 1.0]
it :: Fehler
[0.1,1.0,0.01] 
it :: [Double]
[]
it :: [t]
"Yoda"
it :: [Char]
['Y', 'o', 'd', 'a']
"Yoda"
[Just 0, Nothing, Just 2] 
it :: [Maybe Integer]
[Left True, Right 'a']
it :: [Either Bool Char]
print 'x' 
it :: ()
getChar
*
it :: Char
:t getChar
getChar :: Io Char
:t fst 
fst :: (a,b) -> a
:t snd
snd :: (a,b) -> b
:t head
head :: [a] -> a
:t (++)
(++) :: [a] -> [a] -> [a]
\end{minted}
\subsection{Currying}
\begin{itemize}
\item Recall:\begin{enumerate}
\item $e_1$ \Haskell{++} $e_2 \equiv$ \Haskell{(++)} $e_1 e_2$
\item \Haskell{++} $e_1 e_2 \equiv$ \Haskell{((++)} $e_1) e_2$
\end{enumerate}
\item Function application happens one argument at a time (currying, Haskell B. Curry)
\item Type of n-ary function: : $a_1$ \Haskell{->} $a_2$ \Haskell{... ->} $a_n$ \Haskell{-> b}
\item Type constructor \Haskell{->} associates to the right thus read the type as:\\ $a_1$ \Haskell{->} ($a_2$ \Haskell{->} $a_3$ (\Haskell{... ->} ($a_n$ \Haskell{-> b})\ldots))
\item Enables partial application: ''Give me a value of type $a_1$, I'll give you a (n-1)-ary function of type $a_2$ \Haskell{->} $a_3$ \Haskell{-> ... ->} $a_n$ \Haskell{-> b}
\end{itemize}
\begin{minted}[bgcolor = bg]{Haskell}
"Chew" ++ "bacca"
"Chewbacca"
(++) "Chew" "bacca"
"Chewbacca"
((++) "Chew") "bacca"
"Chewbacca"
:t (++) "Chew"
"Chew" :: [Char] -> [Char]
let chew = (++) "Chew"
chew "bacca"
"Chewbacca"
let double (*) 2
double 21
42
\end{minted}
\section{Vorlesung 3}
\subsection{Defining Values (and thus: Functions)}
\begin{itemize}
\item = binds names to values, names must not start with A-Z (Haskell style: camelCase)
\item Define constant (0-ary) c, value of c is that of expression:\\
c = e
\item Define n-ary function, arguments $x_i$ and f may occur in e (no "letrec" needed)\\
f $x_1\ x_2\ldots x_n = e$
\item Hskell programm = set of top-level bindings (order immaterial, no rebinding)
\item Good style: give type assignment for top-level bindings:\\
\Haskell{f :: a1 -> a2 -> b}\\
\Haskell{f } $x_1$ $x_2$ \Haskell{= e}
\begin{listing}[h!]
\caption{fac in Haskell}
\begin{minted}{Haskell}
fac :: Integer -> Integer
fac n = if n <= 1 then 1 else n * fac (n - 1)

fac2 n | n <= 1    = 1
       | otherwise = n * fac2 (n - 1)

main :: IO ()
main = print $ fac 10
\end{minted}
\end{listing}
\item Guards (introduced by $\vert$).
\begin{minted}[escapeinside=@@]{Haskell}
f @$x_1\ x_2\ \ldots\ x_n$@
  |@$q_1$@ = @$e_1$@
  |@$q_2$@ = @$e_n$@
\end{minted}
\begin{listing}[h!]
\caption{Power in Haskell}
\begin{minted}{Haskell}
power :: Double -> Integer -> Double
power x k | k == 1 = x
          | even k = power (x * x) (halve k)
          | otherwise = x * power (x * x) (halve k)
  where
    even :: Integer -> Bool -- Nicht typisch
    even n  = n `mod` 2 == 0
    halve n = n `div` 2

main :: IO ()
main = print $ power 2 16 
\end{minted}
\end{listing}
\item $q_i$ (expressions of type Bool) evaluated top to bottom, first True guards ''wins''\\
$\mathrm{fac}\ n = \begin{cases}
1 &if n \geq 1\\
n \cdot \mathrm{fac(n-1)}& else
\end{cases}$\\
\end{itemize}
\subsection{Lokale Definitionen}
\begin{enumerate}
\item \Haskell{where} - binding : Local definitions visible in the entire right-hand-side (rhs) of a definition
\begin{minted}[escapeinside=@@]{Haskell}
f @$x_1\ x_2\ \ldots\ x_n$@
  |@$q_1$@ = @$e_1$@
  |@$q_2$@ = @$e_n$@
 where 
    @$g_1$@ ... = @$b_1$@
    @$g_i$@ ... = @$b_i$@
\end{minted}
\item \Haskell{let} - expression Local definitions visible inside an expression:
\begin{minted}[escapeinside=@@]{Haskell}
let @$g_1$@ ... = @$b_1$@
    @$g_2$@ ... = @$b_1$@
in e
\end{minted}
\end{enumerate}
\section{Haskells 2-dimensionale Syntax (Layout) (Forumbeitrag)}
\begin{mdframed}
Hallo zusammen,\\
in der dritten Vorlesung hatte ich erwähnt, dass Haskells Syntax darauf verzichtet, Blöcke (von Definitionen) mittels Sonderzeichen abzugrenzen und zu strukturieren. 
Andere Programmiersprachen bedienen sich hier typischerweise Zeichen wie {, } und ;.\\
Haskell baut hingegen auf das sog. Layout, eine Art 2-dimensionaler Syntax.  Wer schon einmal Python und seine Konventionen zur Einrückung von Blöcken hinter for und if kennengelernt hat, wird hier Parallelen sehen. 
Die Regelungen zu Layout lauten wie folgt und werden vom Haskell-Compiler während der Parsing-Phase angewandt:
\begin{itemize}
\item The first token \textbf{after} a \Haskell{where/let} and the \textbf{first token of a top-level definition} define the upper-left corner of a box.
\item The first token left of the box closes the box (offside rule).
\item Insert a \textit{\{} before the box.
\item Insert a \textit{\}} after the box.
\item Insert a \textit{;} before each line that starts at left box border.
\end{itemize}
Die Anwendung dieser Regeln auf dieses Beispielprogramm:
\begin{minted}{Haskell}
let y   = a * b       
    f x = (x + y) / y 
in  f c + f d
\end{minted}

führt zur Identifikation der folgenden Box:
\begin{verbatim}
   ┌──────────┄┄     
let│y   = a * b      
   │f x = (x + y) / y
   └──────────┄┄     
\end{verbatim}
\Haskell{in  f c + f d}\\  
Das Token in in der letzten Zeile steht links von der Boxgrenze im Abseits (siehe die offside rule).  Der Parser führt nun die Zeichen {, } und ; ein und verarbeitet das Programm so, als ob der Programmierer diese Zeichen explizit angegeben hätte.  (Haskell kann alternativ übrigens auch in dieser sog. expliziten Syntax geschrieben werden — das ist aber sehr unüblich, hat negativen Einfluss aufs Karma und ist vor allem für den Einsatz in automatischen Programmgeneratoren gedacht.)\\
Die explizite Form des obigen Programmes lautet (nach den drei letzten Regeln):
\begin{minted}{Haskell}
let {y   = a * b       
    ;f x = (x + y) / y}
in  f c + f d 
\end{minted}     
Damit ist die Bedeutung des Programmes eindeutig und es ist klar, dass bspw. nicht das folgende gemeint war (in dieser alternativen Lesart ist das Token f aus der zweiten in die erste Zeile "gerutscht"):
\begin{minted}{Haskell}
let y = a * b f    
    x = (x + y) / y
in  f c + f d   
\end{minted}
Aus diesen Layout-Regeln ergeben sich recht einfache Richtlinien für das Einrücken in Haskell-Programmen:
\begin{itemize}
\item Die Zeilen einer Definition auf dem Top-Level beginnen jeweils ganz links (Spalte 1) im Quelltext.
\item Lokale where / let-Definitionen werden um mindestens ein Whitespace (typisch: 2 oder 4 Spaces oder 1 Tab) eingerückt.
\item Es gibt in Haskell ein weiteres Keyword (do, wird später thematisiert), das den gleichen Regeln wie where / let folgt.
\end{itemize}
Beste Grüße,\\
\phantom{ }\qquad —Torsten Grust
\end{mdframed}
\subsection{Lists([a])}
\begin{itemize}
\item Recursive definition:
\begin{enumerate}
\item\Haskell{[]} ist a list (nil), type \Haskell{[] :: [a]}
\item\Haskell{x : xs} (head, tail) is a list, if \Haskell{x :: a}, and \Haskell{xs :: [a]}.\\
\phantom{ }\quad \Haskell{cons: (:) :: a -> [a] -> [a] -> [a]} with \Haskell{infixr : 5}
\end{enumerate}
\item Notation: \Haskell{3:(2:1:[])} $\equiv$ \Haskell{3:2:1:[]} $\equiv$ \Haskell{[3,2,1]}
\end{itemize}
\begin{minted}[bgcolor =bg]{Haskell}
[]
it :: [t]
[1]
it :: [Integer]
[1,2,3]
it :: [Integer]
['z']
"z"
it :: [Char]
['z','x']
"zx"
it :: [Char]
[] == ""
True
it :: Bool
[[1],[2,3]]
it :: [[Integer]]
[[1],[2,3],[]]
[[1],[2,3]]
it :: [[Integer]]
False:[]
[False]
it :: [Bool]
(False:[]):[]
it ::[[Bool]]
:t [(<),(<=),(>)]
[(<),(<=),(>)] :: Ord a => [a -> a-> Bool]
[(1,"one"),(2,"two"),(3,"three")]
it :: [(Integer,[Char])]
:t head
head :: [a] -> a
:t tail :: [a] -> [a]
head "It's a trap"
'I'
it :: Char
tail  "It's a trap"
"t's a trap"
it :: [Char]
reverse "Never odd or even"
"neve ro ddo reveN"
it :: [Char]
\end{minted}
\begin{itemize}
\item Law
$\forall $\texttt{xs}$ \ne$\Haskell{[]}: \Haskell{head xs : tail} = \texttt{xs}
\end{itemize}
\begin{minted}[bgcolor =bg]{Haskell}
:i String
type String = [Char]
\end{minted}
\subsection{Type Synonyms}
\begin{itemize}
\item Introduce your own type synonyms. (type names : {\em U}ppercase)
\Haskell{type} $t_1$ \Haskell{=} $t_2$
\end{itemize}
\begin{minted}{Haskell}
type Bits = [Integer]

type Predicate a = a -> Bool

bits :: Integer -> Bits
bits n | n == 0    =[0]
       | otherwise = (n `mod` 2) : bits (n `div`2)

isEven :: Predicate Integer
isEven n = head (bits n) == 0

main :: IO ()
main = print $ isEven 35
\end{minted}
Sequence (lists of enumerable elements)
\begin{itemize}
\item \Haskell{[x..y]} $\equiv$ \Haskell{[x,x+1,x+2,...,y]}

\begin{minted}[bgcolor= bg]{Haskell}
['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
\end{minted}
\item \Haskell{x,s..y}$\equiv$ \Haskell{[x,x+i,x+(2*i),...,y] where i = x-s}

\begin{minted}[bgcolor= bg]{Haskell}
[1,3..20]
[1,3,5,7,9,11,13,15,17,19]
[2,4..20]
[2,4,6,8,10,12,14,16,18,20]
\end{minted}
\item Infinite List \Haskell{[1..]}
\end{itemize}
\section{Vorlesung 4}
\subsection{Pattern Matching}
\emph{The} idiomatic way to define functions by cases:
\Haskell{f :: }$a_1$ \Haskell{->}$\ldots$\Haskell{->}$a_k$ \Haskell{-> b}\\
\Haskell{f} $p_{11} \ldots p_{1k} = e_1\\$
$\vdots\quad \vdots\quad \vdots\quad \vdots $\\
\Haskell{f} $p_{m1} \ldots p_{nk} = e_n$\\
For all $e_i$ \Haskell{:: b}
on $a_i$ call \Haskell{f} $x_1x_2\ldots x_k$ each $x_i$ is matched against patterns $p_{i1}\ldots p_{in}$ in order. Result is $e_r$ if the rth branch is the first in which all patterns match.\\
\begin{tabular}{lp{4cm}p{4cm}}
Pattern&Matches if\ldots&Bindings in $e_r$\\\hline
constant c&$x_1$ == c\\
variable v&always& v = $x_i$\\
wildcard \_ &always\\
tuple ($p_1,\ldots,p_n$)&components of $x_i$ match type component patterns& Those bound by the component patterns\\
$[]$& $x_i == []$\\
$p_1:p_2$&\Haskell{head} $x_1$ matches $p_1$, \Haskell{tail} $x_i$ matches $p_2$\\
$v@p$& p matches&those bound by $p$ and $v=x_i$
\end{tabular}\\
Note: In a pattern, a variable may only occur once (linear patterns only)
\begin{listing}
\caption{sum in Haskell}
\begin{minted}{Haskell}
--(1) if then else
sum' :: [Integer] -> Integer
sum' xs =
   if xs == [] then 0 else head xs + sum' (tail xs)
--(2) guards
sum'' :: [Integer] -> Integer
sum'' xs | xs == [] = 0
         | otherwise = head xs + sum'' (tail xs)
--(3) pattern matching
sum''' :: [Integer] -> Integer
sum''' []     = 0
sum''' (x:xs) = x + sum''' xs

main :: IO ()
main = do
  print $ sum' [1,2,3]
  print $ sum'' [1,2,3]
  print $ sum''' [1,2,3]
\end{minted}
\end{listing}
\begin{listing}
\caption{ageOf in Haskell}
\begin{minted}{Haskell}
type Dictionary a b = [(a,b)]
type Person = String
type Age = Integer

people :: Dictionary Person Age
people = [("Darth", 46), ("Chewie",200), ("Yoda", 902)]

ageOf :: Dictionary Person Age -> Person -> Maybe Age
-- The old way
--ageOf pas p | fst (head pas) == p = snd (head pas)
--            | otherwise           = ageOf (tail pas) p
ageOf []          p'             = Nothing
ageOf ((p,a):pas) p' | p == p'   = Just a
                     | otherwise = ageOf pas p'

main :: IO ()
main = do
  print $ ageOf people "Luke"
\end{minted}
\end{listing}
\begin{listing}
\caption{take in Haskell}
\begin{minted}{Haskell}
take' :: Integer -> [a] -> [a]
take' 0 _ = []
take' _ [] = []
take' n (x:xs) = x:take' (n-1) xs


main :: IO ()
main = print $ take' 20 [1,3..]
\end{minted}
\end{listing}
\begin{listing}
\caption{merge in Haskell}
\begin{minted}{Haskell}
-- Merge two sorted lists respecting their orderings
--
-- merge (<) [0,3,5] [1,2,4] = [0,1,2,3,4,5]

merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
merge _       []      ys         = ys
merge _       xs      []         = xs
merge (<<<) l1@(x: xs) l2@(y:ys) | x <<< y   = x:merge (<<<) xs l2
                                 | otherwise = y:merge (<<<) l1 ys

main :: IO ()
main = print $ merge (<) [1,3..19] [2,4..20]
\end{minted}
\end{listing}
\begin{listing}
\caption{mergeSort in Haskell}
\begin{minted}{Haskell}
--Sortes a list

mergeSort :: (a -> a -> Bool) -> [a] -> [a]
mergeSort _     []     = []
mergeSort _     [x]    = [x]
mergeSort (<<<) xs = merge (<<<) (mergeSort (<<<) ls)
                                 (mergeSort (<<<) rs)
  where
    (ls,rs) = splitAt (length xs `div` 2) xs
    merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
    merge _         []         ys    = ys
    merge _         xs         []    = xs
    merge (<<<) l1@(x: xs) l2@(y:ys)
      | x <<< y   = x:merge (<<<) xs l2
      | otherwise = y:merge (<<<) l1 ys

main :: IO ()
main = print $ mergeSort (<) [1..100]
\end{minted}
\end{listing}
\subsection{Pattern matching in expressions (case)}
\begin{minted}[escapeinside=@@]{Haskell}
case e of @$p_1$@ | @$q_{11}$@ -> @$e_{11}$@
          @$\vdots$@
          @$p_n$@ | @$q_{n1}$@ -> @$e_{n1}$@
\end{minted}
\end{document}